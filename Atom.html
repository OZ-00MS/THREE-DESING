<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Atom</title>
  <style>
    body { margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script>
/* Scene & Renderer */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* Axes */
scene.add(new THREE.AxesHelper(5));

/* Lights */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const pointLight = new THREE.PointLight(0xffffff, 1);
pointLight.position.set(10, 10, 10);
scene.add(pointLight);

/* Materials & Geometries */
const bigGeom = new THREE.SphereGeometry(1, 32, 32);
const centralMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
const blueMat = new THREE.MeshStandardMaterial({ color: 0x0000ff });

/* Central Red Ball */
const centralBall = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), centralMat);
centralBall.position.set(0, 0, 1);
scene.add(centralBall);

/* Big Balls: 4 blue + 5 red (matches your original layout) */
const bigBalls = [
  { pos: [ 1.2,  0.0,  0.0], mat: blueMat }, // blue
  { pos: [ 0.0,  1.2,  0.0], mat: blueMat }, // blue
  { pos: [ 0.0, -1.2,  0.0], mat: blueMat }, // blue
  { pos: [-1.2,  0.0,  0.0], mat: blueMat }, // blue
  { pos: [ 0.0,  0.0, -1.5], mat: centralMat }, // red
  { pos: [ 1.0,  1.0, -1.0], mat: centralMat }, // red
  { pos: [ 1.0, -1.0, -1.0], mat: centralMat }, // red
  { pos: [-1.0, -1.0, -1.0], mat: centralMat }, // red
  { pos: [-1.0,  1.0, -1.0], mat: centralMat }  // red (the one that was missing)
];
bigBalls.forEach(({pos, mat}) => {
  const m = new THREE.Mesh(bigGeom, mat);
  m.position.set(pos[0], pos[1], pos[2]);
  scene.add(m);
});

/* Orbit circles (keep your original look) */
function createCircle(radius, segments, plane, color = 0xcccccc) {
  const pts = [];
  for (let i = 0; i <= segments; i++) {
    const t = (i / segments) * Math.PI * 2;
    let x = 0, y = 0, z = 0;
    if (plane === 'x') { y = radius * Math.cos(t); z = radius * Math.sin(t); }
    if (plane === 'y') { x = radius * Math.cos(t); z = radius * Math.sin(t); }
    if (plane === 'z') { x = radius * Math.cos(t); y = radius * Math.sin(t); }
    pts.push(new THREE.Vector3(x, y, z));
  }
  const g = new THREE.BufferGeometry().setFromPoints(pts);
  const m = new THREE.LineBasicMaterial({ color });
  const circle = new THREE.LineLoop(g, m);
  scene.add(circle);
  return circle;
}

const radius = 4;
const circleX = createCircle(radius, 64, 'x', 0xcccccc);
const circleY = createCircle(radius, 64, 'y', 0xcccccc);
const circleZ = createCircle(radius, 64, 'z', 0xcccccc);

/* Small yellow orbiting balls */
const smallGeom = new THREE.SphereGeometry(0.3, 16, 16);
const smallMat  = new THREE.MeshPhongMaterial({ color: 0xffff66 });
const ballX = new THREE.Mesh(smallGeom, smallMat);
const ballY = new THREE.Mesh(smallGeom, smallMat);
const ballZ = new THREE.Mesh(smallGeom, smallMat);
scene.add(ballX, ballY, ballZ);

/* Animation parameters */
let angleX = 0, angleY = 0, angleZ = 0;

/* Mouse drag â€” orbit camera at fixed distance so size stays constant */
let isDragging = false;
let prevX = 0, prevY = 0;
let theta = 0;                  // azimuth
let phi   = Math.PI / 2;        // polar
const camRadius = 15;           // fixed distance

function updateCamera() {
  const x = camRadius * Math.sin(phi) * Math.sin(theta);
  const y = camRadius * Math.cos(phi);
  const z = camRadius * Math.sin(phi) * Math.cos(theta);
  camera.position.set(x, y, z);
  camera.lookAt(0, 0, 0);
}
updateCamera();

document.addEventListener('mousedown', (e) => {
  isDragging = true;
  prevX = e.clientX; prevY = e.clientY;
});
document.addEventListener('mouseup', () => { isDragging = false; });
document.addEventListener('mouseleave', () => { isDragging = false; });
document.addEventListener('mousemove', (e) => {
  if (!isDragging) return;
  const dx = e.clientX - prevX;
  const dy = e.clientY - prevY;
  prevX = e.clientX; prevY = e.clientY;

  const ROT_SPEED = 0.005;        // sensitivity
  theta -= dx * ROT_SPEED;
  phi   -= dy * ROT_SPEED;

  // Clamp polar angle to avoid flipping
  const EPS = 0.001;
  phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));

  updateCamera();                 // keeps distance constant -> size constant
});

/* Animate */
function animate() {
  requestAnimationFrame(animate);

  // electron orbits
  angleX += 0.05;
  angleY += 0.05;
  angleZ += 0.05;

  ballX.position.set(0, radius * Math.cos(angleX), radius * Math.sin(angleX));
  ballY.position.set(radius * Math.cos(angleY), 0, radius * Math.sin(angleY));
  ballZ.position.set(radius * Math.cos(angleZ), radius * Math.sin(angleZ), 0);

  // subtle circle motion (optional)
  circleX.rotation.x += 0.003;
  circleY.rotation.y += 0.003;
  circleZ.rotation.z += 0.003;
  scene.rotation.y += 0.005; // slow rotation of the whole scene
  renderer.render(scene, camera);
}
animate();

/* Resize */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
